"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[508],{4604:e=>{e.exports=JSON.parse('{"functions":[{"name":"connect","desc":"Connects a function to the signal. This will be called whenever the signal is fired.\\nConnections can be \\"disconnected\\" (they won\'t be called when the signal is fired) by calling the function that they return.\\n```lua\\nlocal sig = signal()\\n\\n-- You can connect a function like this\\nsig:connect(function(text)\\n\\tprint(text)\\nend)\\n\\n-- You can also directly connect the function like this.\\nsig:connect(print)\\n\\n-- Will print twice, because two connections.\\nsig:fire(\\"Hello, world!\\")\\n```\\n\\nYou shouldn\'t connect the same function twice. This is because the function is used as a reference to disconnect when disconnecting later.\\nWhile it *might* work for simple or specialized cases, you may find that it doesn\'t work as expected in some cases.\\n\\nConnections will be ran in order of connection.\\n\\nIt\'s also worth noting that disconnecting is not an optimal operation, as it will shift the array. If you have a lot of connections to a single signal, you should avoid frequent disconnections.","params":[{"name":"callback","desc":"","lua_type":"(T...) -> ()"}],"returns":[{"desc":"","lua_type":"() -> ()"}],"function_type":"method","source":{"line":109,"path":"src/init.luau"}},{"name":"fire","desc":"Firing a signal will run all connections in order, while using thread reusage.\\n[You can find more on this optimization here](https://devforum.roblox.com/t/thread-reuse-how-it-works-why-it-works/1999166).\\n\\nYou should note these things about thread reusage:\\n- You cannot rely on the thread being different, or the same consistently.\\n- The above means that certain \\"no-yield\\" implementations might not work correctly in connections.\\n- If you have a lot of connections, you should avoid yielding in said connections. Yielding forces a new thread to be spawned, which isn\'t optimal, but it\'s still okay.","params":[{"name":"data","desc":"","lua_type":"..."}],"returns":[{"desc":"","lua_type":"void"}],"function_type":"method","source":{"line":136,"path":"src/init.luau"}},{"name":"once","desc":"Connects to a signal, and disconnects after the first time it is fired.\\nYou can still disconnect the connection before it is fired.","params":[{"name":"callback","desc":"","lua_type":"(T...) -> ()"}],"returns":[{"desc":"","lua_type":"() -> ()"}],"function_type":"method","source":{"line":158,"path":"src/init.luau"}},{"name":"wait","desc":"Yields the current thread until the signal is fired, and returns the arguments passed.\\nWill raise an error if the thread is resumed before the signal is fired.","params":[],"returns":[{"desc":"","lua_type":"T..."}],"function_type":"method","source":{"line":176,"path":"src/init.luau"}},{"name":"disconnectAll","desc":"Disconnects all connections to the signal. This is an efficient operation, utilizing `table.clear`.","params":[],"returns":[],"function_type":"method","source":{"line":197,"path":"src/init.luau"}},{"name":"delete","desc":"Disconnects all connections to the signal, and renders the signal unusable.\\nWhile this technically isn\'t required or needed for memory concerns, you might want to use this when you\'re working with others.\\n\\nThis will prevent and raise an error upon any attempts to use the signal, which is useful for debugging & catching leaks.","params":[],"returns":[],"function_type":"method","source":{"line":210,"path":"src/init.luau"}}],"properties":[],"types":[],"name":"signal","desc":"The main class for this package. It is actually just an array with a metatable! Constructed with:\\n```lua\\nlocal signal = require(...)\\n\\nsignal()\\n```","source":{"line":68,"path":"src/init.luau"}}')}}]);