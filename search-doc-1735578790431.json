{"searchDocs":[{"title":"signal","type":0,"sectionRef":"#","url":"/LuauSignal/api/signal","content":"","keywords":"","version":null},{"title":"Functions​","type":1,"pageTitle":"signal","url":"/LuauSignal/api/signal#functions","content":" ","version":null,"tagName":"h2"},{"title":"connect​","type":1,"pageTitle":"signal","url":"/LuauSignal/api/signal#connect","content":"&lt;/&gt; signal:connect(callback: (T...) → ()) → () → () Connects a function to the signal. This will be called whenever the signal is fired. Connections can be &quot;disconnected&quot; (they won't be called when the signal is fired) by calling the function that they return. local sig = signal() -- You can connect a function like this sig:connect(function(text) print(text) end) -- You can also directly connect the function like this. sig:connect(print) -- Will print twice, because two connections. sig:fire(&quot;Hello, world!&quot;) You shouldn't connect the same function twice. This is because the function is used as a reference to disconnect when disconnecting later. While it might work for simple or specialized cases, you may find that it doesn't work as expected in some cases. Connections will be ran in order of connection. It's also worth noting that disconnecting is not an optimal operation, as it will shift the array. If you have a lot of connections to a single signal, you should avoid frequent disconnections.  ","version":null,"tagName":"h3"},{"title":"fire​","type":1,"pageTitle":"signal","url":"/LuauSignal/api/signal#fire","content":"&lt;/&gt; signal:fire(data: ...) → void Firing a signal will run all connections in order, while using thread reusage.You can find more on this optimization here. You should note these things about thread reusage: You cannot rely on the thread being different, or the same consistently. The above means that certain &quot;no-yield&quot; implementations might not work correctly in connections. If you have a lot of connections, you should avoid yielding in said connections. Yielding forces a new thread to be spawned, which isn't optimal, but it's still okay.  ","version":null,"tagName":"h3"},{"title":"once​","type":1,"pageTitle":"signal","url":"/LuauSignal/api/signal#once","content":"&lt;/&gt; signal:once(callback: (T...) → ()) → () → () Connects to a signal, and disconnects after the first time it is fired. You can still disconnect the connection before it is fired.  ","version":null,"tagName":"h3"},{"title":"wait​","type":1,"pageTitle":"signal","url":"/LuauSignal/api/signal#wait","content":"&lt;/&gt; signal:wait() → T... Yields the current thread until the signal is fired, and returns the arguments passed. Will raise an error if the thread is resumed before the signal is fired.  ","version":null,"tagName":"h3"},{"title":"disconnectAll​","type":1,"pageTitle":"signal","url":"/LuauSignal/api/signal#disconnectAll","content":"&lt;/&gt; signal:disconnectAll() → () Disconnects all connections to the signal. This is an efficient operation, utilizing table.clear.  ","version":null,"tagName":"h3"},{"title":"delete​","type":1,"pageTitle":"signal","url":"/LuauSignal/api/signal#delete","content":"&lt;/&gt; signal:delete() → () Disconnects all connections to the signal, and renders the signal unusable. While this technically isn't required or needed for memory concerns, you might want to use this when you're working with others. This will prevent and raise an error upon any attempts to use the signal, which is useful for debugging &amp; catching leaks. ","version":null,"tagName":"h3"},{"title":"luausignal","type":0,"sectionRef":"#","url":"/LuauSignal/docs/intro","content":"","keywords":"","version":"Next"},{"title":"Why?​","type":1,"pageTitle":"luausignal","url":"/LuauSignal/docs/intro#why","content":" I wanted a typechecked, small, cross-runtime &amp; performant signal implementation which didn't use the same Roblox-based RbxScriptSignal API. None existed, so I made one.  ","version":"Next","tagName":"h2"},{"title":"Basic Features​","type":1,"pageTitle":"luausignal","url":"/LuauSignal/docs/intro#basic-features","content":" Firing and disconnecting (duh)Disconnect allWaitOnceFunction constructor, signal() over signal.new()  ","version":"Next","tagName":"h2"},{"title":"Overview​","type":1,"pageTitle":"luausignal","url":"/LuauSignal/docs/intro#overview","content":" Thread reusageCross-runtime (Roblox, Lune)Strictly typed, with an exported &quot;Identity&quot; type for your type-definition needs.Extremely performant implementation; literally just an array with a metatable. No linked lists here!Automated testing guarantees behavior and stabilityError handling for niche casesBattle-tested. This has been around for a while and I use itFuture-proof (this uses the new solver lol)  ","version":"Next","tagName":"h2"},{"title":"Installation​","type":1,"pageTitle":"luausignal","url":"/LuauSignal/docs/intro#installation","content":" ","version":"Next","tagName":"h2"},{"title":"Wally​","type":1,"pageTitle":"luausignal","url":"/LuauSignal/docs/intro#wally","content":" You can find luausignal under ffrostfall/luausignal@&lt;latest version&gt;.  ","version":"Next","tagName":"h3"},{"title":"Literally just copy pasting​","type":1,"pageTitle":"luausignal","url":"/LuauSignal/docs/intro#literally-just-copy-pasting","content":" You can also just literally copy paste this. It's one file.  ","version":"Next","tagName":"h3"},{"title":"Benchmarks (why not ig)​","type":1,"pageTitle":"luausignal","url":"/LuauSignal/docs/intro#benchmarks-why-not-ig","content":" specs:  64gb 3600mz RAMi79700kf @ ~4.00 GHz (overclocked) 8 cores512kb L1 cache  Numbers are done by the 50th percentile.  Test\tluausignal (μs)\tgoodsignal (μs)Firing (5 connections)\t2.178\t2.124 Firing (0 connections)\t0.038\t0.026 Connecting\t0.104\t0.212 Disconnecting\t0.172\t2.554 Constructing\t0.066\t0.102  ","version":"Next","tagName":"h2"},{"title":"Firing (5 connections) analysis​","type":1,"pageTitle":"luausignal","url":"/LuauSignal/docs/intro#firing-5-connections-analysis","content":" Both luausignal and goodsignal use the same thread reuse method, and are doing nearly the exact same operations. However, arrays are slightly cheaper than linked lists at the end of the day.  ","version":"Next","tagName":"h3"},{"title":"Firing (0 connections) analysis​","type":1,"pageTitle":"luausignal","url":"/LuauSignal/docs/intro#firing-0-connections-analysis","content":" Again, nearly identical except for a handful of CPU cycles.  Goodsignal wins due to it's usage of linked lists. Iterating over a zero-length array is slower than iterating over a zero-length linked list.  ","version":"Next","tagName":"h3"},{"title":"Connecting analysis​","type":1,"pageTitle":"luausignal","url":"/LuauSignal/docs/intro#connecting-analysis","content":" Luausignal wins by a decent margin here because inserting into an array is substantially faster than inserting into a linked list.  ","version":"Next","tagName":"h3"},{"title":"Disconnecting analysis​","type":1,"pageTitle":"luausignal","url":"/LuauSignal/docs/intro#disconnecting-analysis","content":" Luausignal wins by an incredibly large margin here. This is because, again, arrays are faster than linked lists! table.find and table.remove  ","version":"Next","tagName":"h3"},{"title":"Constructor analysis​","type":1,"pageTitle":"luausignal","url":"/LuauSignal/docs/intro#constructor-analysis","content":" Luausignal wins here for obvious reasons: constructing an array with a metatable is faster than a dictionary. ","version":"Next","tagName":"h3"}],"options":{"id":"default"}}